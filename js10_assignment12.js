'use strict';

// Code 1
console.log('start');

const promise1 = new Promise((resolve, reject) => {
console.log(1)
resolve(2)
})

promise1.then(res => {
console.log(res)
})

console.log('end');

/* Тлумачення
Код іде зверху вниз, зразу виводимо start. 
Далі оголошується проміс, відпрацьовує код всередині, виводиться 1 в консолі.
поки ресолвиться проміс в відпрацьовує then, код не чекає і відпрацьовує далі
по порядку і виводиться end. після чого приходить результат відпрацювання 
асинхронного коду і виводиться результат у вигляді виведення в консоль 2,
переданних в ресолві.
*/

// Code 2

Promise.resolve(1)
		.then((x) => x + 1)
		.then((x) => { throw new Error('My Error') })
		.catch(() => 1)
		.then((x) => x + 1)
		.then((x) => console.log(x))
		.catch(console.error)

		/* Результат роботи коду
		Кожна частинка коду, розділена catch відпрацьовує окремо.
		В цьому коді в першій частині немає консоль логу, тому нічого
		виводитись не буде. В другій частині, після першого catch, в функцію
		для x передається значення 1. 1(тобо х)+1=2, і в натупному then ми
		консоль логом просто виводимо це значення 2(тобто х). проміс fulfilled,
		тому помилку ніяку не ловим. 
		*/

// Code 3

const promise = new Promise(res => res(2));
	promise.then(v => {
	        console.log(v);
	        return v * 2;
	    })
	    .then(v => {
	        console.log(v);
	        return v * 2;
	    })
	    .finally(v => {
	        console.log(v);
	        return v * 2;
	    })
	    .then(v => {
	        console.log(v);
	    });

		/* Коментар
		в цьому коді ми передаєм в проміс через res(2) значення 2 для v.
		Далі починається chain. В першій ітерації ми зразу відображаємо
		значення 2 для v і повертаємо 2*2=4
		В другій ітерації для v приходить одразу значення 4 з попереднього then.
		Ми його виводимо в консоль, після чого повертаєм 4(v)*2=8. Тобто повертаєм 8.
		Finally не підтягує значення з попередніх then і не знає що таке v - тому в 
		консоль лог попадає undefined.
		В останньому then ми вивоим значення повернене з другого then, тобто 8. */